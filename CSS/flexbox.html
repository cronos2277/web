<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flex-Box</title>
    <style>
        /*
            BASICO de FLEXBOX:
            display:flex => Eh o minimo necessario para que funcione o modo flex.

            FLEX-DIRECTION
            Aqui voce define quem eh o main-axis e quem eh o cross-axis, existe 4 opcoes possiveis,
            row, row-reverse, column, column-reverse, por padrao eh row para desktops e column para
            mobile, o padrao eh definido com base na orientacao da tela.
            row => O sentido eh da esquerda para direita, sendo o main-axis o eixo X e o cross-axis o eixo Y.
            row-reverse => O sentido eh da direita para esquerda, sendo o main-axis o eixo X e o cross-axis o eixo Y.
            column => O sentido de cima para baixo, sendo o main-axis o eixo Y e o cross-axis o eixo X.
            column => O sentido eh de baixo para cima, sendo o main-axis o eixo Y e o cross-axis o eixo X.

            JUSTIFY-CONTENT e ALIGN-ITENS. (Atributos de Container)
            justify-content(main-axis) vs align-itens(cross-axis): Eles servem para alinhar, porem um alinha 
            pelo main-axis e o outro para o cross-axis. No caso o justify-content define a posicao pelo
            main-axis e o align-itens pelo cross-axis, main-axis eh o sentido dado para a distribuicao dos
            elementos internos dentro do componente, podendo ser horizontal se for (row ou row-reverse) e
            vertical se for (column ou column-reverse), o main-axis eh definido no atributo flex-direction, sendo 
            o cross-axis o complemento de main-axis, ou seja se o main-axis esta na horizontal o cross esta na
            vertical. Exemplo:            
            "flex-direction:row ou row-reverse" => justify-content corresponde ao comportamento eixo X e o align-itens ao eixo Y.
            "flex-direction:column ou column-reverse" => Inverte, nesse caso o justify seria o eixo Y e o align o eixo X.
            "align-itens" => A posicao dos elementos com base no eixo definido no flex-direction.
            "justify-content" => A posicao dos elementos complementar ao do flex-direction.
            Esses dois atributos servem para definir elementos internos, ou seja como serao posicionados.
            stretch => Ele estica o elemento verticalmente ou horizontalmente dependendo o flex-direction.
            baseline => Ele alinha com base no conteudo ou seja faz um alinhamento de modo que o conteudo esteja alinhado.
            space-around => Espaco envolta, ou seja ele da um espaco entre os elementos e as bordas.
            space-between => Espaco apenas entre os elementos e exclui as bordas.
            flex-start => Alinha tudo no eixo x=0 ou y=0 de acordo com o flex-direction.
            flex-end => alinha tudo ao final, ou seja a direita se row, abaixo se column.

            FLEX-BASIS
            Se o main-axis for o eixo X ele passa a determinar o width, 
            sendo que o valor se sobrepoe ao width pois eh mais especifico.
            Se o main-axis for o Y ele passa a determinar o height, 
            sendo que o valor se sobrepoe ao Height pois eh mais especifico.
            Voce pode usar o width e o height de maneira complementar ao flex-basis, ou seja se ele estiver em 
            sentido row ou row-reverse, voce pode usar o height como complementar ao passo que se tiver no sentido
            column ou column reverse voce pode usar o width como complementar e dessa forma ele pode selecionar
            o valor de height ou width para ser o tamanho que ele usara como cross-axis automaticamente.

            FLEX-WRAP
            Habilita a quebra de linha em um container flex. Por padrao caso o conteudo exceda o tamanho maximo de
            um flex container com o direction em row, ele da um overflow e continua colocando os elementos em linha
            ignorando o width dele, quando voce ativa o wrap, voce passa a colocar o excedente abaixo e caso
            voce informe um wrap-reverse ai ele coloca o excedente acima. Eh valido lembrar que se o direction
            for column a "quebra de linha" sera a direita se for wrap ou a esquerda se for wrap-reverse. O Ponto eh,
            um elemento filho dentro de um container flexbox nao respeita os limites do pai e flutua os seus limites,
            ou seja se o pai tem um flex-direction:row e um width de 500px e cada filho tem 200px, por padrao o
            teceiro filho ficaria ao lado do segundo filho, porem com o wrap setado ele poderia ir para baixo ou
            para cima, uma vez que esse terceiro filho nao caberia, nessa situacao ao lado do segundo, pois excediria
            o width do pai em 100px.

            ALIGN-CONTENT
            Caso voce use o flex-wrap, como a ultima linha ou coluna deve se comportar? Justamente para resolver
            esse problema, serve esse atributo. No exemplo do flex-wrap acima de um flex-direct row, com 500px,
            sendo que cada filho teria 200px, nesse caso nos iriamos definir como iria ser posicionado o terceiro
            filho, aquele que esta na linha debaixo criado pelo wrap, se ele ficaria mais a esquerda, mais a direita,
            ou se teria um stretch talvez... No so isso, ele alinha as multiplas linhas na aplicacao
            
        */
        body,html{
            background-color: black;
            height: 100%;
        }
        hr{
            background-color: white;
            margin-top: 30px;
            margin-bottom: 30px;
        }
        h1{
            background-color:white;     
            font-size: 1.8rem;  
            margin-left: 10px;            
        }
        div.container{
            /*
                Definir o display eh o minimo necessario para definir o
                display como flex, com ele voce tem um espaco unidimencional
                para se mover, por padrao o "flex-direction" eh row, ou
                seja o efeito seria semelhante ao "float:left", todos os 
                itens vao sendo ordenados da esquerda para a direita, nao
                respeitando o width, ou seja em uma posicao flex o elemento
                ultrapassa a largura do elemento pai ficando parte dele para
                fora, fique atento a isso, ele tem um comportamento muito
                semelhante ao float, ou seja ele pode se sobrepor a elementos.
            */
            display: flex;         
            margin-bottom: 10px;   
        }
        div.container div{
            width: 25vw;
            height: 10vh;  
            font-size: xx-large;
            font-weight: 900;          
        }
        div.container div div{
            background-color: rgba(255,255,255,.7);
            border-color: black;
            border-width: 2px;
            border-style: solid;
        }

        .flex-row{
            background-color: magenta;
            display: flex;       
            /* 
                Essa coluna poderia ser omitida, pois eh o valor padrao. Segue o
            mesmo racicinio do float left, porem quando chega a 100% da largura 
            ele continua colocando elemento, mesmo que isso ultrapasse a largura
            maxima e fique invisivel ao usuario.
            */  
            flex-direction: row;   
        }
        .flex-column{
            background-color: aqua;
            display: flex;
            /*
                O Sentido com esse flex-direction, seria em coluna, ou seja comecando
            no y=0 e sendo posicionado o proximo elemento abaixo do outro elemento.
            */
            flex-direction: column;
        }
        .flex-reverse-row{
            background-color: yellow;
            display:flex;
            /*
                Na pratica se comporta como um float:right, ou seja coloca todos os
                elememtos posicionados a direita e os inverte, fique atento a isso,
                o primeiro elemento fica a direita dos demais e o ultimo mais a 
                esquerda.
            */
            flex-direction: row-reverse;
        }
        .flex-reverse-column{
            background-color: chartreuse;
            display:flex;
            /*
                Inverte a logica da coluna, nessa direcao o ultimo elemento passa
            a ocupar a posicao y=0, e ficando o primeiro elemento mais abaixo.
            */
            flex-direction: column-reverse;
        }     
        #wrap-column{
            /*
                flex-wrap no caso caso nao caiba no main axis, ele passa a usar
                o cross axis, ou seja, esse elemento esta usando o "flex-direction:column",
                caso nao tenha espaco no flex-direction de coluna ele coloca o elemento
                ao lado nesse exemplo, ou seja se for "row" ele coloca um elemento ao lado
                do outro e caso nao caiba ele coloca em baixo, se for "column", entao ele
                usara de colunas e se nao couber todos um em baixo do outro, ele comeca
                uma nova fila ao lado. Essa propriedade habilita isso.
            */
            flex-wrap: wrap;
            height: 25vh;            
        }   
        #wrap-row{
            /*
                Aqui nos temos um outro exemplo de como funciona o flex-wrap, como esse
                direction esta como row, entao ao habilitar o wrap, ao atingir o limite
                de largura o elemento passa a ocupar a outra linha, mas como aqui estamos
                usando o wrap-reverse, logo ao inves dessa linha ficar em baixo, como
                eh de se esperar quando o direction eh row, essa linha vai para cima,
                uma vez que o wrap esta invertido.
            */
            flex-wrap: wrap-reverse;
            width: 60vw;
            margin-top:100px;
            align-content: center;            
        }
        #flex-grow{
            /*
                Esse atributo pode funcionar como width ou height conforme o contexto,
                se for row, ela sempre vai se sobrepor ao width, se for column esse
                valor ira se sobrepor ao height. Esse atributo basico do flex ele
                determina o tamanho do elemento de acordo com o direction, correspondendo
                ao width e sobscrevendo o valor dele ser a direcao for row e correspondendo
                e sobrescrevendo o height, caso o direction seja column.
            */
            flex-basis: 90vw;            
        }
        #flex-grow div{
            flex-basis: 10vw;
        }
        /*
            O flex-grow ou shrink ele vai priorizar ou preterir esse elemento, caso tenha que redistribuir
            o espaco extra. Por padrao se sobrar espaco dentro do elemento, o espaco fica em branco, 
            mas quando se tem um grow e um shrink, voce define a maneira com que esse espaco extra sera
            distribuido. Por exemplo se todos os elementos tem o grow 1 ou o shrink 1, todos receberam
            igualmente o mesmo espaco.
        */
        .grow{      
            /*
                caso o grow seja maior que 1 ele comeca a receber mais espaco, ou seja se o grow for 2, 
                ele passa a ter o peso de dois e ele tera 2 partes do espaco que sobrou, se for 3, sera
                pego 3 partes e por ai vai de acordo com o numero do grow. Voce vera a presenca dele
                quando sobrar espaco, no caso os espacos extras serao concentrados nos grow. Ou seja
                quando sobrar espaco, quando houver um aumento nesse elemento que sera concentrado
                esse espaco extra.
            */      
            flex-grow: 4;            
            background-color: green !important;
            color: white;
            padding-left: 10px;
        }
        .shrink{
            /*
                O shrink eh o exato oposto do grow, no caso o elemento sera preterido, no caso se o shrink
                for 2 ele recebera a metade da parte destinada a ele, enquanto todos receberam 1 parte do
                espaco que sobrou, esse elemento recebe meio, ou seja ele eh preterido e a logica se assemelha
                ao grow. O shrink voce vai perceber quando o espaco eh menor, no caso quando o tamnho eh reduzido
                eh tirado mais dos shrink do que dos outros elementos, nesse caso ele eh visado quando o
                momento propicio for tirar dimensao de um elemento, ou seja ele ira diminuir mais que os
                outros elementos, quando faltar espaco e for necessario um redirecionamento.
            */
            flex-shrink: 4;            
            background-color: red !important;
            color: white;
            padding-left: 10px;
        }
        .normal{
            /*
                Voce tambem pode colocar o grow e o shrink dentro de um shorthand, no caso o "flex".
                O primeiro valor eh o grow, o segundo eh o shrink e o terceiro eh o basis dele, ou
                seja quando nao for dado as condicoes de grow ou shrink, qual seria a dimensao dele?
                Informe isso no terceiro parametro.
            */
            flex: 1 1 10vh;
            background-color: yellow !important;
            color: black;
            padding-left: 10px;
        }
        /*
            Por fim no display flex, existe o atributo order, que define a prioridade de renderizacao,
            o zero eh o padrao, quanto menor o valor mais ao topo da fila o elemento vai estar,
            quando maior o valor de ordem, mais preterido ele sera, ou seja ele sera renderizado
            depois dos elementos tem um ordem maior, caso nao seja definido uma order, prevalece
            a posicao do elemento mesmo, ou seja o que estiver em cima no codigo vem primeiro,
            mas para quebrar essa regra temos o atributo order.
        */
        .priorize{
            order: -1;
            background-color:blue !important;
            color:yellow;            
        }
        .preterize{
            order: 1;
            background-color:yellow !important;
            color:blue;
        }        
        #justify-content{           
            /*
                Aqui estamos definido a posicao dos elementos internos com base no main-axis, conforme explicado acima.
            */
            justify-content:space-around;
            /*
                Aqui estamos definido a posicao dos elementos internos com base no cross-axis, conforme explicado acima.
            */
            align-items: flex-end;                      
        }         
        .align-self1{   
            /*
                Nao confundir com o align-items, o items ele eh focado no posicionamento cross-axis de elementos internos,
                este atributo tem a mesma logica, mas o target eh o proprio elemento. Ele alinha o elemento com base no
                cross-axis do pai, ou seja se voce quiser definir a posicao cross-axis de um elemento em especifico,
                voce pode usar esse atributo o "align-self" que significa alinhe o proprio elemento. Mas lembre-se sempre
                par nao confundir justify-content e align-items definem o comportamento de elementos internos, ou seja
                dentro dele, ao tempo que o align-self define a posicao de cross-axis para o proprio elemento. O align-self
                sempre sobrescreve o valor de align-items por ser mais especifico, fique atento a isso.
            */             
            align-self: flex-end;
            background-color:green !important;
            color:magenta;
        }       
        .align-self3{              
            align-self: center;            
            background-color: magenta !important;
            color:green;            
        }        
        .align-self4{
            align-self: flex-end;
            background-color:green !important;
            color:magenta;
        }
        .align-self6{
            align-self: center;
            background-color: magenta !important;
            color:green;
        }
        #flex-column-altura{
            height: 60vh;
            width: 90vw;
            background-color: black;
        } 
        .vertical-centro{
            align-self: center;            
            background-color: magenta !important;
            color:black;
        }
        .vertical-fim{
            align-self: flex-end;
            background-color: yellow !important;
            color:black;
        }      
    </style>
</head>
<body>
    <div class="container">
        <div>
            <h1>Flex-Row</h1>
        </div>
        <div>
            <h1>Flex-Column</h1>
        </div>
        <div>
            <h1>Flex-Row-Reverse</h1>
        </div>
        <div>
            <h1>Flex-Column-Reverse</h1>
        </div>
    </div>
    <div class="container">        
        <div class="flex-row">            
            <div>1</div>
            <div>2</div>
            <div>3</div>
        </div>
        <div class="flex-column">
            <div>1</div>
            <div>2</div>
            <div>3</div>
        </div>
        <div class="flex-reverse-row">
            <div>1</div>
            <div>2</div>
            <div>3</div>
        </div>
        <div class="flex-reverse-column">
            <div>1</div>
            <div>2</div>
            <div>3</div>
        </div>
    </div>
    <hr>  
    <div class="container">          
        <div>
            <h1>flex-direction:column;<br>flex-wrap:wrap;</h1>
        </div>
    </div>    
    <div class="container">        
        <div id="wrap-column" class="flex-column">
            <div>1</div>
            <div>2</div>
            <div>3</div>
        </div>       
    </div>
    <hr>
    <div class="container">          
        <div>
            <h1>flex-direction:row;<br>flex-wrap:wrap-reverse;<br>align-content:center;</h1>
        </div>
    </div>      
    <div class="container">
        <div id="wrap-row" class="flex-row">
            <div>1</div>
            <div>2</div>
            <div>3</div>
        </div>
    </div>
    <hr>
    <div class="container">        
            <h1>Verde = flex-grow: 4;</h1>
            <h1>Vermelho = flex-shrink: 4;</h1>            
            <h1>Amarelo = none</h1>
    </div>
    <br>
    <div class="container">        
        <div id="flex-grow" class="flex-row">            
            <div class="shrink">1</div>
            <div class="grow">2</div>
            <div class="normal">3</div>
            <div class="grow">4</div>
            <div class="shrink">5</div>
        </div>
    </div>
    <hr>
    <div class="container">
        <h1>ORDER:\d</h1>        
        <h1>align-self:(flex-end|center)</h1>        
    </div>
    <div id="justify-content" class="container">
        <div id="flex-grow" class="flex-row" style="height: 20vh;background-color: lightgray;">
            <div class="align-self1">1st</div>
            <div class="preterize">2nd</div>
            <div class="align-self3">3rd</div>
            <div class="align-self4">4th</div>
            <div class="priorize">5th</div>
            <div class="align-self6">6th</div>
        </div>
    </div>  
    <hr>
    <div class="container">          
        <div>
            <h1>align-self na vertical com flex-direction:column</h1>
        </div>
    </div>   
    <div class="container">
        <div id="flex-column-altura" class="flex-column">
            <div>1</div>
            <div class="vertical-centro">2</div>
            <div class="vertical-fim">3</div>
            <div class="vertical-centro">4</div>
            <div class="vertical-fim">5</div>
            <div>6</div>
        </div>
    </div>
    <hr>
</body>
</html>